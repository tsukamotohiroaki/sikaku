LPIC_Lv1-101(Ver5.0)
1.システムアーキテクチャ
■ハードウェア設定の決定と設定
・BIOS/UEFIで設定できるもの
起動デバイスの優先順位
デバイスの有効/無効化

・キーボード、マウスなどが属しているUSBのデバイスクラス
HID(Human Interface Devices)

・スピーカー、マイクなどが属しているUSBのデバイスクラス
Audio Class

・D-Bus（Desktop Bus）についての説明
Linuxで使われるプロセス間通信機構

・モデム、TA(ターミナルアダプタ)などが属しているUSBのデバイスクラス
ACM Communication Device Class

・ホットプラグデバイスを接続した際に、デバイスファイルを動的に作成する仕組み
udev(Userspace DEVice management)

・ハードディスク、USBメモリーなどが属しているUSBのデバイスクラス
Mass Storage Class

・lspciコマンドで取得できる情報
I/Oポートアドレス
ベンダー名（ベンダーID）
バスの速度
IRQ番号

・大容量記憶装置の特徴
SSDとUSBフラッシュドライブは、HDDのような機械的な故障が起きない
容量あたりのコストパフォーマンスが高いのはHDDである
OSの起動ディスクとして使用できる
SSDはSATAインターフェース以上の速度でアクセスできる

・modprobeの設定ファイルに記述する設定内容
options: 各カーネルモジュールのデフォルトパラメータを指定する
alias: カーネルモジュールに別名をつける
install: 特定のカーネルモジュールのロード時に実行されるコマンドを指定する
remove: 特定のカーネルモジュールのアンロード時に実行されるコマンドを指定する
blacklist: ロードしたくないカーネルモジュールを指定する

・依存関係を考慮してカーネルモジュールをロードまたはアンロードするコマンド
modprobe

・起動中のプロセスやカーネルが認識しているハードウェアおよびシステムリソースなどの情報が格納されているディレクトリ
/proc

・CPUに関する情報を確認できるファイル
/proc/cpuinfo

・メモリの使用状況を確認できるファイル
/proc/meminfo

・I/Oポートアドレスの情報を確認できるファイル
/proc/ioports

・SCSIデバイスに関する情報が確認できるファイル
/proc/scsi/scsi

・接続されたUSBデバイスの情報を表示するコマンド
lsusb
cat /proc/bus/usb/devices

・PCIデバイスの情報を表示するコマンド
lspci
cat /proc/bus/pci/devices
※PCI(Peripheral Components Interconnect)デバイスとは、PCIバスに接続されたデバイスのこと

・ロードされているカーネルモジュールの情報を表示するコマンド
lsmod
cat /proc/modules

・デバイスが使用中のDMAチャネルに関する情報が確認できるファイル
/proc/dma
※DMAとは、CPUを介することなくメインメモリと周辺機器の間で直接的に情報転送を行う方式のこと

・IRQに関する情報が格納されているファイル
/proc/interrupts
※IRQ(Interrupt ReQuest)とは、マウスやキーボードなどの周辺機器(デバイス)からCPUへの割り込み要求のこと

・udevが使用するデバイス設定情報ファイルの所在
/etc/udev/rules.d

・modprobeの設定ファイル
/etc/modprobe.d/myconfig.conf

■システムの起動
・Linux システムの起動順序（ブートプロセス）
BIOS/UEFI → ブートローダ → カーネル → init

・システム起動時においてのブートローダの説明
記憶装置（HDD）内のカーネルをロードし、制御を移す

・BIOSの特徴
電源を入れると起動し、記憶装置（HDD）等に関して最低限の認識を行う
起動する順にデバイスの先頭セクタにあるMBRを読み込み、ブートローダが得られたら制御を移す
起動デバイスの順序を設定できる

・UEFIの特徴
GUIでの操作が可能となる
最初にアクセスされる領域であるESPは「/boot/efi」にマウントされる
GPTというパーティション形式に対応しており、3TB以上のHDDからの起動をサポートする

・システム起動時においてのカーネルの説明
高度にハードウェアを認識・制御し、ルートファイルシステムのマウントなど様々な初期化処理を行う
/sbin/initを起動する

・従来のinitプログラムを置き換えるsystemdの特徴
扱う処理をUnitという単位で管理する
サービスの並列起動によって高速なシステム起動や停止が行える
cgroupsでプロセスのリソースを管理する

・SysVinitを採用したシステムの起動時におけるinitの説明
設定ファイル「/etc/inittab」の記述に基づいて、自動起動するべきプロセスを立ちあげるなど、アプリケーションレベルの初期化を行う

・systemdの管理単位であるユニット
※Unitには各機能ごとに拡張子が割り当てられており、拡張子を見ることでどういった機能のためのUnitかが判別できるようになっています。
device：各種デバイスを管理するUnit
mount：ファイルシステムのマウントを管理するUnit
service：サービスを制御するUnit
swap：スワップ領域を管理するUnit
target：複数のサービスを一つのグループにするためのUnit

・initプログラムであるUpstartの特徴
サービスやタスクを「ジョブ」という単位で扱う
イベント駆動型
サービスの並列起動処理が可能

・100GBの記憶装置(HDD)を接続したが、実際の半分以下の容量で認識されてしまった場合の解決方法
BIOSをアップデートする

・Linuxがハードディスクから正常に起動できなくなった場合、インストールDVDを用いて試してみるべきこととして適切なもの
レスキューモードでの起動を試みる
ハードディスク内のログを確認する

・システム起動時にブートローダからカーネルに渡されたパラメータが確認できるファイル
/proc/cmdline

・カーネルのログなどが記録されるLinuxでメインのログファイル
/var/log/messages

・起動時にカーネルが出力したメッセージを表示するコマンド
dmesg

・マシンを再起動せずにカーネルのリングバッファの内容をクリアするコマンド
dmesg --clear
※dmesgコマンドはカーネルが出力するメッセージが格納されるリングバッファの内容を出力する。

・initのPID(プロセス ID)
1
※initは最初に起動されるプロセスで、PID（プロセス ID）は必ず1です。

・systemctlコマンドを使って、postfixサービスに設定ファイルを再読み込みさせるコマンド
systemctl reload postfix

・systemdが管理するサービスを再起動させるためのsystemctlコマンドのサブコマンド
restart

・systemdが利用できるユニットの一覧を取得するコマンド
systemctl list-unit-files

・systemdが稼働するシステムにおいて、各サービスが稼働しているかを確認するためのサブコマンド
is-active
例)systemctl is-active sshd

・各サービスの稼働状況や起動設定を管理するにはsystemctlコマンド
systemctl status httpd

・systemdを管理するためのコマンド
systemctl

・systemdの動作するシステムにおいて、各サービスが出力するログを扱うデーモンプロセス
systemd-journald

・systemdが稼働するシステムにおいてpostfixサービスを停止するコマンド
systemctl stop postfix

・systemdが稼働するシステムにおいてmysqldサービスを起動するコマンド
systemctl start mysqld

・systemdが稼働するシステムにおいて、システム起動時にhttpdサービスが自動起動させないためのコマンド
systemctl disable httpd

・systemdが稼働するシステムにおいて、システム起動時にhttpdサービスが自動起動するためのコマンド
systemctl enable httpd

・systemdが管理するジャーナル（システムログ）を参照するためのコマンド
journalctl
※systemdの動作するシステムではsystemd-journaldデーモンを動作させ、ログの一元管理を行います。

・journalctlコマンドのオプションで、dmesgコマンドと同じ情報を得られるオプション
-k
--dmesg

■ランレベル/ブートターゲットの変更
・SysVinitを採用したシステムの特徴
ランレベル3では「/etc/rc3.d」配下のスクリプトが実行される
※SysVinitでは、システムの起動時やランレベルの変更時にinitが「/etc/inittab」を参照し、ランレベルに応じたスクリプトを実行して各種サービスを順に起動/停止していきます。
※各ランレベルに応じたスクリプトは「/etc/rc[0-6].d」に入っています。

・SysVinitを採用したシステムにおいて、シングルユーザモードでのブートプロセス中にサービスを停止させるファイル
/etc/rc1.d/K01bluetooth
※SysVinitでは、システムの起動時やランレベルの変更時にinitが「/etc/inittab」を参照し、ランレベルに応じたスクリプトを実行して各種サービスを順に起動/停止していきます。
※各ランレベルに応じたスクリプトは「/etc/rc[0-6].d」に入っています。

・SysVinitを採用したシステムの設定ファイルで、デフォルトのランレベルの設定ファイル
/etc/inittab

・SysVinitを採用したシステムにおいて、「ctrl+alt+del」キーを押下した際のシステムの動作を設定するファイル
/etc/inittab

・SysVinitの設定ファイル「/etc/inittab」を編集した。即座に変更を反映させるコマンド
init Q
telinit q
※/etc/inittabファイルとは、OSを起動する際、OSの起動を司る「initプロセス」が利用するファイルです。
※/etc/inittabファイルは、デフォルトのランレベルの指定、デバイスなどの初期化、initの起動、ブート時の処理、ランレベルごとのrcスクリプトの実行などを指示します。
※SysVinitの設定ファイル「/etc/inittab」ファイルは通常Linuxシステムの起動時に読み込まれます。
※initまたはtelinitコマンドに「q」か「Q」オプションを指定して実行すると、「/etc/inittab」を再読み込みさせ即座に変更を反映させることができます。

・「/etc/inittab」を設定ファイルとして使用しないinitプログラム
Upstart
systemd
※Upstartやsystemdは、従来のSysVinitと比べてシステム起動時の初期化作業が高速化されています。
※Upstarは、イベント駆動型の初期化プロセス
※Upstartでは初期化時の依存関係を定義する必要がある
※Upstartは「/etc/event.d/rc-default」ファイルの「telinit 2」の部分を編集することでデフォルトのランレベルを設定できます。
※systemdでは、「/lib/systemd/system/runlevel[0-6].target」ファイル([0-6]部分はランレベルを指定)のシンボリックリンクを「/etc/systemd/system/default.target」として作成することでデフォルトのランレベルを設定できます。

・systemdの動作するシステムにおいて、次回起動時にメンテナンスを行うために最低限のシステムサービス状態で起動させたい。次回起動時のターゲットとしてどれを指定すればよいか
rescue.target
runlevel1.target

・systemdの動作するシステムにおいて、メンテナンスのために以下のコマンドでシングルユーザーモードに変更し、作業を行った。
# systemctl rescue
作業が終わったので通常の起動状態に戻したい。どうすれば良いか
Ctrl-Dを入力する
systemctl reboot コマンドを実行する
systemctl default コマンドを実行する

・systemdが稼働するシステムにおいて、次回起動時のランレベルの確認作業を行った。
/etc/systemd/system
default.target

・systemdが稼働するシステムにおいて、次回起動時のターゲットが確認できるsystemctlのサブコマンド
get-default

・systemdが稼働するシステムにおいて、次回起動時のターゲットを設定するためのsystemctlのサブコマンド
set-default

・systemdが稼働するシステムにおいて、次回起動時にグラフィカルログインさせるコマンド
rm -f /etc/systemd/system/default.target
ln -s /lib/systemd/system/graphical.target /etc/systemd/system/default.target

・systemdが稼働するシステムにおいて、次回起動時にグラフィカルログインさせるコマンド
systemctl set-default graphical.target

・systemdの動作するシステムにおいて、サーバとして動作させるのに適切な起動時のターゲット
runlevel3.target
multi-user.target

・すでにマルチユーザモードで起動しているシステムをメンテナンスのためにシングルユーザモードに変更するコマンド
init s
telinit 1
telinit S

・ランレベル6の説明
システム再起動

・デフォルトのランレベルとして、設定してはいけないもの
0
6

・現在のランレベルを、どのランレベルにでも変更できるコマンド
init
telinit

・現在および1つ前のランレベルを調べることができるコマンド
runlevel

・マルチユーザモードとなるランレベル
2
3
5

・ランレベル0の説明
システム停止
※ランレベルとはLinuxの動作モードのことです。

・systemctl start poweroff.target を実行すると何が起こるか
システム終了処理が行われる
telinit 0と同じことが起こる

・システムを今すぐ再起動させるコマンド
reboot
telinit 6
shutdown -r now

・23:00にシステムを停止するようshutdownコマンドをキャンセルするコマンド
shutdown -c

・現在22:50である。「Rebooting in 10 minutes」というメッセージを表示して、23:00にサーバを再起動するコマンド
shutdown -r 23:00 "Rebooting in 10 minutes"
shutdown -r +10 "Rebooting in 10 minutes"

・現在22:00である。23:00にサーバを停止するコマンド
shutdown -h 23:00
shutdown -h +60

・システムを今すぐ再起動させるコマンド
telinit 6
shutdown -r now
systemctl reboot
systemctl start reboot.target

・シャットダウン処理を行わず、メッセージ通知のみを行うshutdownコマンドのオプション
-k

・システムを停止させるsystemctlコマンドのサブコマンド
halt
poweroff

・ログイン中の全ユーザーにメッセージを送信するコマンド
wall

・電源管理に関するACPIイベントを監視・処理するデーモン
acpid

2.Linuxのインストールとパッケージ管理
■ハードディスクのレイアウト設計
・物理的な記憶デバイスの領域をまとめ、それを論理的なひとつの大きな記憶デバイスとして扱うことで、物理的なパーティションの仕様に由来する制限を回避できるシステム
LVM

・LVMの説明
論理ボリュームを動的にリサイズすることができる
ボリュームグループは、物理ボリュームを集めて構成された仮想的な領域である
ボリュームグループに対し、後から物理ボリュームを加えたり、削除したりできる
スナップショットを取得することができる

・ESP（EFIシステムパーティション）の説明
UEFIを使ったシステムの領域である
ブートローダや起動に必要なドライバなどが置かれている

・論理ボリュームを作成するまでの手順
pvcreate, vgcreate, lvcreate
※物理ボリューム(PV)の作成：pvcreateコマンド
※ボリュームグループ(VG)の作成：vgcreateコマンド
※論理ボリューム(LV)の作成：lvcreateコマンド

・Linuxシステムを構築するに当たって、推奨構成として必要なパーティション
ルートパーティション
スワップ領域

・Linuxをインストールする際、ルートパーティションから分割できないディレクトリ
/lib
/dev
/sbin

・Linuxをインストールする際、ルートパーティションから分割できないディレクトリ
/bin
/sbin
/etc

・Linuxをインストールする際、ルートパーティションとは別のパーティションを割り当てる事が可能なディレクトリ
/boot
/tmp

・Linuxをインストールする際、ルートパーティションとは別のパーティションを割り当てる事が可能なディレクトリ
/home
/usr
/tmp
/var

・一般ユーザが書き込みできることによりディスク使用量が大きくなる可能性が高いため、ルートパーティションとは別のパーティションを割り当てた方がよいディレクトリ
/home
/tmp

・システム管理者用のコマンドを格納するディレクトリ
/sbin

・一時ファイルを格納するためのディレクトリで、再起動すると中身が削除されるディレクトリ
/tmp

・Linuxカーネルなど、システムを起動するために必須のファイルを格納するディレクトリ
/boot

・パーティションの設計について
/varは高速に書き込みできるディスクに割り当てる

・システム固有の設定ファイルを格納するディレクトリ
/etc

・ユーザ数百人が利用すると想定されるファイルサーバを構築したい。ルートパーティションとは別のパーティションとして構成した方がよいと考えられるディレクトリ
/home

・デバイスファイルを格納するディレクトリ
/dev

・追加のパッケージが格納され、ルートパーティションとは別のパーティションを割り当てた方がよいディレクトリ
/opt

・システムの起動には必須で無いプログラムやライブラリが格納されたディレクトリ
/usr

共有ライブラリを格納するディレクトリ
/lib

・アプリケーションのログファイルや一時的な電子メールファイルなど、可変ファイル群を格納するディレクトリ
/var

・一般ユーザ用のコマンドを格納するディレクトリ
/bin

・スワップ領域の説明
物理メモリが1GBの場合、物理メモリの2倍程度のサイズにする

・512MBのメモリを搭載したシステムがある。適切なswap領域のサイズ
1GB

■ブートマネージャのインストール
・GRUB LegacyとGRUB2の説明
GRUB Legacyの設定ファイルは「/boot/grub/menu.lst」である
GRUBのバージョンが1.9以降のものを「GRUB2」と呼ぶ
パーティション番号は、GRUB Legacyは0から、GRUB2は1から数える

・GRUB2の設定ファイルにおいて、各項目の名前としてメニューに表示するエントリ名を指定する項目
menuentry

・ブートローダであるGRUB Legacyの設定ファイル
/boot/grub/menu.lst
/boot/grub/grub.conf

・ブートローダであるGRUB2の設定ファイル
/boot/grub/grub.cfg
※「/boot/grub/grub.cfg」ファイルを直接編集することはありません。設定内容は「/etc/default/grub」ファイルおよび「/etc/grub.d」ディレクトリ内のファイルに記述し、「grub-mkconfig」コマンドで設定内容を「/boot/grub/grub.cfg」ファイルに反映させます。

・ブートローダであるGRUB Legacyの設定ファイル「/boot/grub/menu.lst」を編集した。変更内容を反映させるコマンド
実行するコマンドはない
※GRUB Legacy（GRUB1）は設定ファイル「/boot/grub/menu.lst」を変更しても、実行するコマンドはありません。

・ブートローダであるGRUB2の設定ファイルの内容を変更したい。変更内容を反映させるコマンド
grub-mkconfig

・GRUB2の設定ファイルにおいて、ロードするモジュールを指定する項目
insmod

・GRUB2の設定を直接編集できるファイル
/etc/default/grub
「/etc/grub.d」ディレクトリ内のファイル

・ブートローダであるGRUB LegacyまたはGRUB2をインストールするコマンド
grub-install

・GRUB Legacyの設定ファイル「/boot/grub/menu.lst」において、ルートパーティションを2番目のディスクの3番目のパーティションに指定する方法
root (hd1,2)
※GRUB Legacy（GRUB1）の設定ファイル「/boot/grub/menu.lst」でルートパーティションを指定するには、「root (hdディスク番号,パーティション番号)」と指定します。その際、番号はどちらも0から数えます。

・GRUB Legacyの設定ファイル「/boot/grub/menu.lst」において、ルートパーティションを1番目のディスクの4番目のパーティションに指定する方法
root (hd0,3)
GRUB Legacy（GRUB1）の設定ファイル「/boot/grub/menu.lst」でルートパーティションを指定するには、「root (hdディスク番号,パーティション番号)」と指定します。その際、番号はどちらも0から数えます。

・GRUB Legacyの設定ファイル「/boot/grub/menu.lst」において、システム起動時のカーネルイメージ「/boot/vmlinuz-2.6.35 」と起動オプションを指定するコマンド
kernel /boot/vmlinuz-2.6.35 root=/dev/hda1

・GRUB2の設定ファイル「/boot/grub/grub.cfg」の抜粋です。ルートパーティションを2番目のディスクの3番目のパーティションに指定するコマンド
set root=______________
(hd1,3)
※GRUB2でパーティションを指定する際は、「(hdディスク番号,パーティション番号)」のように指定します。ディスク番号は0から、パーティション番号は1から数えます。

・GRUB2の設定ファイル「/boot/grub/grub.cfg」の抜粋です。ルートパーティションを1番目のディスクの4番目のパーティションに指定したい。下線部の記述として適切なものは次のうちどれか。
set root=______________
(hd0,4)
※GRUB2でパーティションを指定する際は、「(hdディスク番号,パーティション番号)」のように指定します。ディスク番号は0から、パーティション番号は1から数えます。

・ルートパーティションを「/dev/sda2」に指定して起動させるコマンド
grub> linux /boot/vmlinuz-2.6.35 root=/dev/sda2

・「/sbin/init」の代わりに「/bin/bash」を起動するコマンド
grub> kernel /boot/vmlinuz-2.6.35 init=/bin/bash

・メンテナンス用にシングルユーザモードで起動するコマンド
grub> kernel /boot/vmlinuz-2.6.35 _____________
1
s
single

・起動中のカーネルから出力される情報を抑制するコマンド
grub> linux /boot/vmlinuz-2.6.35 quiet
※grub> linux カーネルイメージ [オプション]

・第一段階のブートローダが通常格納される場所
MBR（マスターブートレコード）

・コマンドの実行結果
# dd if=/dev/zero of=/dev/sda bs=446 count=1
ブートローダのみがゼロクリアされる

・ブートローダにGRUBを使っているHDDに追加で別のOSをインストールしたところ、MBR（マスターブートレコード）が書き換えられてしまい、GRUBが起動しなくなってしまった。バックアップからHDDのMBRを復元したいが既存のパーティションテーブルは残しておきたい。
上記の要件にしたがって作業を行うにあたって、以下のコマンドの空欄に当てはまるもの
# dd if=mbr_backup.img of=/dev/sda bs=[　　　] count=1
440
446

・systemdの動作するシステムにおいて、シングルユーザーモードで起動したい。適切なカーネルパラメータ
systemd.unit=rescue

■共有ライブラリの管理
・共有ライブラリの検索パスを設定する環境変数
LD_LIBRARY_PATH

・あるプログラムが必要としている共有ライブラリを表示するコマンド
ldd

・「/bin/bash」を実行するときに必要となる共有ライブラリを調べるためのコマンド
ldd /bin/bash

・共有ライブラリのキャッシュファイル「/etc/ld.so.cache」を更新するコマンド
ldconfig

・一般的な共有ライブラリの格納場所として間違っているもの
/lib/shared

・プログラムの実行時に、共有ライブラリの場所を検索するために使用されるファイル
/etc/ld.so.cache

・共有ライブラリを格納するためのディレクトリを新たに作成した。ldconfigコマンドを使用して共有ライブラリのキャッシュファイルを更新するためには、どのファイルに新しいディレクトリのパスを記述する必要があるか。
/etc/ld.so.conf

■Debianパッケージ管理
・APTツールにおいてapt-getとapt-cacheの機能を統合したコマンド
apt

・APTツールにおいてインターネット上ないしはメディア上のパッケージ情報のデータベースを使い、依存関係を調整しながら、パッケージのインストール・アンインストール・アップグレードを行うことができるコマンド
apt-get

・apt-getコマンドを使用して、パッケージのデータベースを最新版に更新したい。
apt-get update

・apt-getコマンドを使用して、過去に取得したパッケージファイルを削除したい。
apt-get clean

・apt-getコマンドを使用して、ディストリビューションを最新版にしたい。
apt-get dist-upgrade

・apt-getコマンドを使用して、「apache2」パッケージをインストールしたい。
apt-get install apache2

・apt-getコマンドを使用して、インストール済みの全パッケージをアップグレードしたい。
apt-get upgrade

・apt-getコマンドを使用して、「apache2」パッケージをアンインストールしたい。
apt-get remove apache2

・apt-getコマンドの「update」と「upgrade」サブコマンドの説明として正しいもの
「update」はパッケージのデータベースを最新版に更新する
「upgrade」はインストール済の全パッケージのアップグレードを行う

・apt-cacheコマンドを使用して、キーワード「ssh」を含むパッケージを表示させたい。
apt-cache search ssh

・apt-cacheコマンドを使用して、「ssh」パッケージのサイズやファイル名などを含めた情報を表示させたい。
apt-cache show ssh

・apt-cacheコマンドを使用して、「ssh」パッケージが依存しているパッケージの名前を一覧表示させたい。
apt-cache depends ssh

・apt-cacheコマンドを使用して、「ssh」パッケージへ依存しているパッケージを含めた詳細情報を表示させたい。
apt-cache showpkg ssh

・APTツールではネットワーク経由で最新のパッケージを取得することができる。パッケージの取得元(リポジトリ)を設定するファイル
/etc/apt/sources.list

・APTツールにおいてapt-getとapt-cacheの機能を統合したコマンド
apt

・dpkgツールにおいてパッケージのインストール・アンインストールなど、基本的なパッケージ管理を行うコマンド
dpkg

・dpkgコマンドを使用して、「procmail_3.22-16_i386.deb」パッケージをインストールしたい。但し、既に新しいバージョンのパッケージがインストールされている場合には、インストールを行いたくない。
dpkg -Gi procmail_3.22-16_i386.deb
dpkg -G --install procmail_3.22-16_i386.deb
※インストールを行うアクションは「-i(--install)」です。また、「-G」オプションを併用することで、既に新しいバージョンのパッケージがインストールされている場合は、インストールを行わないようにすることができます。

・dpkgコマンドを使用して、「procmail_3.22-16_i386.deb」パッケージをインストールしたい。
dpkg -i procmail_3.22-16_i386.deb
dpkg --install procmail_3.22-16_i386.deb

・dpkgツールにおいてインストール済みのパッケージを、インストールした時と同じように再設定するコマンド
dpkg-reconfigure

・dpkgコマンドを使用して、「/usr/share/doc/ssh」ファイルのインストール元パッケージを表示させたい。
dpkg -S /usr/share/doc/ssh
dpkg --search /usr/share/doc/ssh

・dpkgコマンドを使用して、インストールが完了していない不完全なパッケージを表示したい。
dpkg -C
dpkg --audit

・dpkgコマンドを使用して、「procmail」パッケージを設定ファイルを残してアンインストールしたい。
dpkg -r procmail
dpkg --remove procmail

・dpkgコマンドを使用して、「packages」ディレクトリに格納されているパッケージをまとめてインストールしたい。
dpkg -Ri packages
dpkg -R --install packages

・dpkgコマンドを使用して、「procmail_3.22-16_i386.deb」パッケージをインストールしたい。但し、既に同じバージョンのパッケージがインストールされている場合には、インストールを行いたくない。
dpkg -Ei procmail_3.22-16_i386.deb
dpkg -E --install procmail_3.22-16_i386.deb

・dpkgコマンドを使用して、「procmail」パッケージを設定ファイルを含めて全てアンインストールしたい。
dpkg -P procmail
dpkg --purge procmail

・dpkgコマンドを使用して、インストール済みのパッケージを一覧表示させたい。
dpkg -l
dpkg --list

・dpkgコマンドを使用して、「ssh」パッケージからインストールされたファイルを一覧表示させたい。
dpkg -L ssh
dpkg --listfiles ssh

・dpkgコマンドを使用して、「ssh」パッケージの詳細情報を表示させたい。
dpkg -s ssh
dpkg --status ssh

・dpkgコマンドの「-r」と「-P」アクションの説明として正しいもの
「-r」は設定ファイルを残してパッケージをアンインストールする
「-P」は設定ファイルを含め完全にパッケージをアンインストールする

・dpkgツールの設定ファイル
/etc/dpkg/dpkg.cfg

■RPMとYUMパッケージ管理
・YUMツールの説明として正しいものはどれか。
ネットワーク経由で最新のパッケージを取得することができる
YUMの組み込み変数がある

・インターネット上ないしはメディア上のパッケージ情報のデータベースを使い、依存関係を調整しながら、パッケージのインストール・アンインストール・アップグレードを行うことができるコマンド
yum

・yumコマンドの後継であり、yumと同様のオプションやリポジトリを使用できるコマンド
dnf

・yumコマンドを使用して、アップデート可能な全てのパッケージをアップデートしたい。
yum update

・yumコマンドを使用して、アップデート可能なパッケージを確認したい。
yum check-update

・yumコマンドを使用して、キーワード「yum」を含むパッケージを表示させたい。
yum search yum

・yumコマンドを使用して、「php」パッケージがインストールされているかどうか確認したい。ただし、「php」パッケージの詳細な情報は必要ない。
yum list php

・yumコマンドを使用して、「php」パッケージの詳細な情報を表示させたい。
yum info php

・yumコマンドを使用して、「php」パッケージをインストールしたい。
yum install php

・yumコマンドを使用して、パッケージグループを一覧表示させたい。
yum grouplist

・yumコマンドを使用して、「Emacs」パッケージグループをインストールしたい。
yum groupinstall Emacs

・yumコマンドを使用して、「php」パッケージをアンインストールしたい。
yum remove php

・YUMツールではネットワーク経由で最新のパッケージを取得することができる。パッケージの取得元(リポジトリ)を設定するファイルが格納されているディレクトリ
/etc/yum.repos.d

・YUMツールの設定ファイル
/etc/yum.conf

・RPMツールにおいてパッケージのインストール・アンインストールなど、基本的なパッケージ管理を行うコマンド
rpm

・rpmコマンドを使用して、「postfix」パッケージがインストールされているかどうか確認したい。
rpm -q postfix
rpm --query postfix

・rpmコマンドを使用して、「/etc/yum.conf」ファイルのインストール元パッケージを表示させたい。
rpm -qf /etc/yum.conf
rpm --query --file /etc/yum.conf

・rpmコマンドを使用して、インストールされている「postfix」パッケージに含まれるファイルを調べたい。
rpm -ql postfix
rpm --query --list postfix

・rpmコマンドを使用して、インストールされている「postfix」パッケージの詳細情報を調べたい。
rpm -qi postfix
rpm --query --info postfix

・rpmコマンドを使用して、インストールされている「postfix」パッケージの変更履歴を調べたい。
rpm -q --changelog postfix
rpm --query --changelog postfix

・rpmコマンドを使用して、インストールされる前に「postfix-1.1.12-1.i386.rpm」ファイルでパッケージの詳細情報を確認したい。
rpm -qip postfix-1.1.12-1.i386.rpm
rpm --query --info --package postfix-1.1.12-1.i386.rpm

・rpmコマンドを使用して、インストールする前に「postfix-1.1.12-1.i386.rpm」ファイルの変更履歴を確認したい。
rpm -qp --changelog postfix-1.1.12-1.i386.rpm
rpm --query -p --changelog postfix-1.1.12-1.i386.rpm

・rpmコマンドを使用して、「postfix」パッケージからインストールされた設定ファイルのみを表示させたい。
rpm -qc postfix
rpm --query --configfiles postfix

・rpmコマンドを使用して、インストール前に「postfix-1.1.12-1.i386.rpm」ファイルからインストールされるファイルを調べたい。
rpm -qlp postfix-1.1.12-1.i386.rpm
rpm --query --list --package postfix-1.1.12-1.i386.rpm

・rpmコマンドを使用して、インストール前の「emacs-23.1-28.el6.x86_64.rpm」パッケージの依存関係を調べたい。
rpm -qRp emacs-23.1-28.el6.x86_64.rpm
rpm --query --requires --package emacs-23.1-28.el6.x86_64.rpm

・rpmコマンドを使用して、システムにインストールされている全てのパッケージを表示させたい。
rpm -qa
rpm --query --all

・rpmコマンドを使用して、インストールされている全パッケージの検査を行いたい。
rpm -Va
rpm --verify --all

・rpmコマンドを使用して、「postfix」パッケージの検査を行いたい。ただし、MD5によるファイルの改ざんの検査は行わないものとする。
rpm -V --nomd5 postfix
rpm --verify --nomd5 postfix

・rpmコマンドを使用して、「postfix-1.1.12-1.i386.rpm」ファイルからインストールされる設定ファイルのみを表示させたい。
rpm -qcp postfix-1.1.12-1.i386.rpm
rpm --query -cp postfix-1.1.12-1.i386.rpm

・rpmコマンドを使用して、「procmail-3.22-9.i386.rpm」パッケージをインストールしたい。元々「procmail」がインストールされていない場合、これが可能なコマンド
rpm -i procmail-3.22-9.i386.rpm
rpm -U procmail-3.22-9.i386.rpm

・rpmコマンドを使用して、「procmail-3.22-25.1.el6.i686.rpm」パッケージを新規インストールする際、進行状況を表示させたい。
rpm -ih procmail-3.22-25.1.el6.i686.rpm
rpm -i --hash procmail-3.22-25.1.el6.i686.rpm

・rpmコマンドを使用して、「procmail-3.22-25.1.el6.i686.rpm」パッケージを新規インストールする際、詳細情報を表示させたい。
rpm -iv procmail-3.22-25.1.el6.i686.rpm
rpm --install -v procmail-3.22-25.1.el6.i686.rpm

・rpmコマンドを使用して、「procmail-3.22-9.i386.rpm」パッケージを新規インストールする前にエラーなどが出ないかを確認したい。
rpm -i --test procmail-3.22-9.i386.rpm
rpm --install --test procmail-3.22-9.i386.rpm

・rpmコマンドを使用して、「procmail」パッケージを「procmail-3.22-9.i386.rpm」にアップグレードしたい。また、パッケージが存在しない場合はインストールしたい。
rpm -U procmail-3.22-9.i386.rpm
rpm --upgrade procmail-3.22-9.i386.rpm
※-Uは指定したパッケージがなければインストールする。
※-Fは指定したパッケージが存在しなければインストールしない。

・rpmコマンドを使用して、「procmail」パッケージを「procmail-3.22-9.i386.rpm」にアップグレードしたい。ただし、「procmail」パッケージが存在しない場合は、新たにインストールしたくない。
rpm -F procmail-3.22-9.i386.rpm
rpm --freshen procmail-3.22-9.i386.rpm
※-Uは指定したパッケージがなければインストールする。
※-Fは指定したパッケージが存在しなければインストールしない。

・rpmコマンドを使用して、依存関係を無視して「postfix」パッケージを強制的にアンインストールしたい。
rpm -e --nodeps postfix
rpm --erase --nodeps postfix

・RPM系パッケージをcpio形式のアーカイブに変換するコマンド
rpm2cpio

・rpmコマンドの「-V（--verify）」オプションについて、正しい説明
RPMデータベースに格納されているファイルに関する情報と、インストールされたパッケージのファイルに関する情報を比較して変更（改ざんなど）が無いか検査する
検査する内容は主にファイルのサイズ、MD5チェックサム、所有ユーザ、所有グループ、タイムスタンプである

・openSUSEで採用されている、パッケージ管理を行うコマンド
zypper

・zypperコマンドを使用して、リポジトリの一覧を表示させたい。
zypper repos
zypper lr

・zypperコマンドを使用して、リポジトリを更新したい。
zypper refresh

・zypperコマンドを使用して、「emacs」パッケージをアンインストールしたい。
zypper remove emacs
zypper rm emacs

・zypperコマンドを使用して、キーワード「vim」を含むパッケージを表示させたい。
zypper search vim
zypper se vim

・zypperコマンドを使用して、「emacs」パッケージの詳細な情報を表示させたい。
zypper info emacs

・zypperコマンドを使用して、「emacs」で始まる名前のパッケージをすべてインストールしたい。
zypper install emacs*
zypper in emacs*

・zypperコマンドを使用して、アップデート可能な全てのパッケージをアップデートしたい。
zypper update
zypper up

・zypperコマンドを使用して、「emacs」パッケージをインストールしたい。
zypper install emacs
zypper in emacs

・zypperコマンドを使用して、アップデート可能なパッケージを確認したい。
zypper list-updates
zypper lu

■仮想化のゲストOSとしてのLinux
・クラウドで提供する仮想化環境について正しい説明はどれか。
仮想マシンのことをインスタンスと呼ぶ
仮想マシンへのOSのインストールはテンプレートを利用できる
ブログサービス環境などのように、ユーザの用途に応じて利用可能なコンテナをアプリケーションコンテナと呼ぶ

・クラウドにおけるサービスモデルのうち、ソフトウエアをサービスとして提供するものはどれか。
SaaS
※SaaS（Software as a Service）は、ソフトウエアをサービスとして提供します。
※ユーザはインフラも開発環境も意識することなく、単純にソフトウエアを利用する、というサービスを受けることができます。

・クラウドにおけるサービスモデルのうち、ソフトウエアの開発、実行環境をサービスとして提供するものはどれか。
PaaS
※PaaS（Platform as a Service）は、ソフトウエアの開発、実行環境をサービスとして提供します。ユーザは環境構築や保守に気を遣わずに、開発に専念できます。また、仮想化により、規模をあらかじめ把握できなくても柔軟に増減できるメリットがあります。

・クラウドにおけるサービスモデルのうち、サーバ、ストレージ、ネットワーク等、仮想化されたインフラ環境をサービスとして提供するものはどれか。
IaaS
※IaaS（Infrastructure as a Service）は、サーバ、ストレージ、ネットワーク等、仮想化されたインフラ環境をサービスとして提供する、サーバの仮想化技術と関連が深いサービスモデルです。HaaS（HardWare as a Service）と呼ばれることもあります。
※IaaSでは仮想マシンや仮想ネットワーク、ブロックストレージ（ハードディスク）などのリソースを、ユーザにサービスとして提供しています。

・IaaSで提供するリソースは次のうちどれか。
仮想マシン
仮想ネットワーク
ブロックストレージ

・クラウドインスタンスを展開するためにインスタンスの構成やカスタマイズを行えるLinuxのパッケージはどれか。
cloud-init

・ハイパーバイザー型の仮想化の説明として正しいものはどれか。
物理マシン上でハイパーバイザーを起動し、その上で仮想マシンとゲストOSを動作させる
ハイパーバイザーがサポートしていれば、動作させるゲストOSの種類に制限はない
※仮想化（Virtualization）とは、コンピュータリソースを実際の物理的な構成にとらわれず、論理的に分割・統合して提供する技術です。
※仮想化の種類の1つであるハイパーバイザー型は、物理マシンで動作するハイパーバイザー（仮想化のための専用のOS）上で直接仮想マシンを起動し、ゲストOSを動作させる方式です。物理マシンのハードウェアをエミュレー卜（模倣）する完全仮想化を実現できます。
※ハイパーバイザーがサポートしている種類のゲストOSであれば、LinuxやWindows、macOSなども使用できます。

・コンテナ型仮想化のソフトウェアは次のうちどれか。
LXC
Docker

・コンテナ型の仮想化の説明として正しいものはどれか。
オーバーヘッドが少なく、リソース・構築・管理の面がシンプルである
Linuxカーネルの機能によってコンテナごとのユーザ管理やリソース制限ができる

・一つの仮想化ソフトウェア上で同じ仮想マシンのクローンをいくつか動作させたい場合、重複してはならないものはどれか。
UUID
IPアドレス
SSHホスト鍵
マシンID

3.GNUとUnixコマンド
■コマンドラインでの作業
・シェル変数と環境変数の違いについて、正しいものを二つ選べ。
シェル変数は、変数を設定したシェル上でのみ有効な変数で、exportすることによって環境変数とすることができる
環境変数は、設定が子プロセスに引き継がれる

・コマンド履歴を保存するファイルのパスを格納する環境変数
HISTFILE

・シェル変数LPICの値をtestにするコマンド
LPIC=test

・以下のようにしてシェル変数LPICを設定した。このシェル変数を環境変数にするコマンド
$ LPIC=study_linux
export LPIC

・ロケールを格納する環境変数
LANG

・環境変数PATHの説明として正しいもの
パスを指定しなくてもコマンドを実行できるようにするために使用される
シェルは環境変数PATHに定義されたパスから、入力されたコマンドの実行ファイルを順に探す

・ログインしているユーザ名を格納する環境変数
USER

・設定されている全ての環境変数を一覧表示できるコマンド
set
env
printenv

・現在の環境変数PATHに「/usr/local/test」ディレクトリを追加したい。空欄に当てはまるものはどれか。
$ export PATH=$PATH:/usr/local/test
※環境変数PATHに値を追加する場合は「export PATH=$PATH:値」のようにして行います。

・ログインしているユーザのホームディレクトリを格納する環境変数
HOME

・現在のシェルでのコマンド履歴の保存数を格納する環境変数
HISTSIZE

・カレントディレクトリのパスを格納する環境変数
PWD

・ホスト名を格納する環境変数
HOSTNAME

・シェルから起動したアプリケーションやコマンドでも有効な環境変数を作成したり、シェル変数を環境変数に変更したりできるコマンド
export
※環境変数とは、変数を設定したシェル上と、そこから起動されるシェルやアプリケーション、コマンドで有効な変数です。
※環境変数はexportコマンドを使用して作成することができます。

・bashのシェル変数LPICを削除するコマンドは次うちどれか。
unset LPIC

・設定されている全てのシェル変数を一覧表示するコマンド
set

・パスを指定しなくてもコマンド(プログラム)を実行できるようにしたい。次のどの環境変数の値を編集すればよいか。
PATH

・多くのディストリビューションで採用される、デフォルトのシェル
bash

・bashシェルにおいて、一般ユーザのプロンプトの末尾に表示される記号
$

・カレントディレクトリの1つ上の階層（親ディレクトリ）を表す特殊記号
..

・bashシェルにおいて、スーパーユーザ(root)のプロンプトの末尾に表示される記号
#

・カレントディレクトリを表す特殊記号
.
※「.」は、カレントディレクトリにある、パスが通っていないプログラムを実行する場合にも良く使用されます。
例)カレントディレクトリにある、パスが通っていない「program」という名のプログラムを実行する場合
$ ./program

・/etc/crontabについてのmanページを参照したい。
$ man 5 crontab

・shutdownコマンドのmanページセクションはどれか
8

・sambaというキーワードを一部に含むmanページを検索するコマンド
man -k samba
apropos samba

・lsコマンドのオンラインマニュアルを参照するコマンド
man ls

・ファイル名「xyz.txt」に一致するワイルドカード
xy?.txt
[a-z][a-z][a-z].txt
*[xyz].txt

・command1を実行し、続けてcommand2を実行したい。なお、command1の実行結果はcommand2を実行するか否かには関係しない。
command1 ; command2

・command1を実行し、続けてcommand2を実行させたい。ただし、command1が失敗した場合はcommand2を実行しないこととする。
command1 && command2

・command1を実行し、command1が失敗した場合のみcommand2を続けて実行させたい。
command1 || command2

・以下はhistoryコマンドを実行した結果である。
「cat hoge.txt」を再実行するにはどのように入力すればよいか。
!3

・カレントディレクトリのパスを表示するコマンド
pwd

・bashシェルには文字補完機能があります。この機能を使うためのキー
tab

・bashシェルで実行したコマンドの履歴を表示するコマンドと、履歴を保存するファイル
history
.bash_history

・コマンド履歴保存ファイルに記録が残らないように以下のとおり作業を行った。
HISTFILESIZE=0

・変数DATEに「date」という文字列(現在の日時を表示するコマンド)を格納した。以下のコマンドの実行結果
$ echo '$DATE'
$DATE

・「DATE=`date`」というコマンドを実行した後に以下のコマンドを実行した結果
$ echo \"$DATE\"
"dateコマンドを実行した時の日時"

・変数DATEに「date」という文字列(現在の日時を表示するコマンド)を格納した。以下のコマンドの実行結果
$ echo "$DATE"
date

・変数DATEに「date」という文字列(現在の日時を表示するコマンド)を格納した。以下のコマンドの実行結果
$ echo `$DATE`
現在の日時
※「`」（バッククォーテーション）はシェルによって特別に解釈されるメタキャラクタの1つです。
※シェルは「`」で囲まれた文字列(変数の場合は、変数に格納されている値)をコマンドと見なし、そのコマンドの実行結果を文字列として使用します。

・任意の1文字を表すメタキャラクタ
?

・0文字以上の文字列を表すメタキャラクタ
*

・変数を表すために使用されるメタキャラクタ
$

・passwdというキーワードと完全に一致した名前を含むmanページを検索するコマンド
man -f passwd
whatis passwd

・/etc/crontabファイルの書式について調べるためにmanページを参照することにしたが、開いたmanページの冒頭は以下のようになっていた。
manページのセクション番号を指定していない
man 5 crontab

・whatisデータベースを作成するコマンド
makewhatis

・現在使用しているシステムの情報を表示するコマンド
uname

・ファイルの内容をページ(1画面)ごとに表示するが、編集はできないコマンド
less
more

・ホームディレクトリに\workディレクトリを作成することができるコマンドはどれか
mkdir ~/\\work

・現在ログインしているユーザはrootである。testユーザのホームディレクトリに移動できるコマンド
cd ~test

・現在ログインしているユーザはtestである。testユーザのホームディレクトリに移動できるコマンド
cd ~
cd ~test
cd

